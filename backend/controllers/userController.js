// backend/controllers/userController.js
const User = require('../models/User');
const logger = require('../utils/logger');
const { ValidationError, AuthorizationError } = require('../utils/errorTypes');

/**
 * @desc    Update or set username
 * @route   POST /api/users/username
 * @access  Private
 */
exports.setUsername = async (req, res) => {
  try {
    const { username, address, isAutoGenerated } = req.body;
    
    if (!username || !address) {
      return res.status(400).json({
        success: false,
        error: 'Please provide username and address'
      });
    }
    
    // NOTE: Address verification happens in the middleware
    // We could add an extra check here for non-Magic users
    
    // Check if username is already taken by another user
    if (!isAutoGenerated) {
      const existingUser = await User.findOne({ 
        username,
        address: { $ne: address.toLowerCase() } 
      });
      
      if (existingUser) {
        return res.status(400).json({
          success: false,
          error: 'Username is already taken'
        });
      }
    } else {
      // For auto-generated usernames, make sure it's unique
      let baseUsername = username;
      let counter = 1;
      let uniqueUsername = baseUsername;
      
      while (true) {
        // Check if this username exists for another user
        const existingUser = await User.findOne({ 
          username: uniqueUsername,
          address: { $ne: address.toLowerCase() }
        });
        
        if (!existingUser) {
          // Username is unique or belongs to this user
          break;
        }
        
        // Try next number
        uniqueUsername = `${baseUsername}_${counter}`;
        counter++;
      }
      
      // Use the unique username
      req.body.username = uniqueUsername;
    }
    
    // Use findOneAndUpdate with upsert to create or update the user in one atomic operation
    // This handles the case where the user might exist in blockchain but was deleted from DB
    const user = await User.findOneAndUpdate(
      { address: address.toLowerCase() }, // Query
      { 
        address: address.toLowerCase(),
        username: req.body.username,
        isAutoGenerated: !!isAutoGenerated
      },
      {
        new: true, // Return the updated document
        upsert: true, // Create if it doesn't exist
        setDefaultsOnInsert: true, // Apply default values if creating
        runValidators: true // Run model validators on update
      }
    );
    
    logger.info(`Username set/updated for address ${address}: ${req.body.username}`);
    
    res.status(200).json({
      success: true,
      data: {
        address: user.address,
        username: user.username,
        isAutoGenerated: user.isAutoGenerated
      }
    });
  } catch (error) {
    logger.error(`Error setting username: ${error.message}`, error);
    res.status(500).json({
      success: false,
      error: error.message || 'Server Error'
    });
  }
};

/**
 * @desc    Get user profile
 * @route   GET /api/users/profile/:address
 * @access  Public
 */
exports.getUserProfile = async (req, res) => {
  try {
    const address = req.params.address.toLowerCase();
    
    const user = await User.findOne({ address });
    
    if (!user) {
      return res.status(404).json({
        success: false,
        error: 'User not found'
      });
    }
    
    res.status(200).json({
      success: true,
      data: {
        address: user.address,
        username: user.username,
        isAutoGenerated: user.isAutoGenerated,
        createdAt: user.createdAt
      }
    });
  } catch (error) {
    logger.error(`Error getting user profile: ${error.message}`, error);
    res.status(500).json({
      success: false,
      error: error.message || 'Server Error'
    });
  }
};